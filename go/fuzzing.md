Fuzzing Â¶

'go test' and the testing package support fuzzing, a testing technique where a function is called with randomly generated inputs to find bugs not anticipated by unit tests.

Functions of the form

func FuzzXxx(*testing.F)

are considered fuzz tests.

For example:

func FuzzHex(f *testing.F) {
  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {
    f.Add(seed)
  }
  f.Fuzz(func(t *testing.T, in []byte) {
    enc := hex.EncodeToString(in)
    out, err := hex.DecodeString(enc)
    if err != nil {
      t.Fatalf("%v: decode: %v", in, err)
    }
    if !bytes.Equal(in, out) {
      t.Fatalf("%v: not equal after round trip: %v", in, out)
    }
  })
}

A fuzz test maintains a seed corpus, or a set of inputs which are run by default, and can seed input generation. Seed inputs may be registered by calling (*F).Add or by storing files in the directory testdata/fuzz/<Name> (where <Name> is the name of the fuzz test) within the package containing the fuzz test. Seed inputs are optional, but the fuzzing engine may find bugs more efficiently when provided with a set of small seed inputs with good code coverage. These seed inputs can also serve as regression tests for bugs identified through fuzzing.

The function passed to (*F).Fuzz within the fuzz test is considered the fuzz target. A fuzz target must accept a *T parameter, followed by one or more parameters for random inputs. The types of arguments passed to (*F).Add must be identical to the types of these parameters. The fuzz target may signal that it's found a problem the same way tests do: by calling T.Fail (or any method that calls it like T.Error or T.Fatal) or by panicking.

When fuzzing is enabled (by setting the -fuzz flag to a regular expression that matches a specific fuzz test), the fuzz target is called with arguments generated by repeatedly making random changes to the seed inputs. On supported platforms, 'go test' compiles the test executable with fuzzing coverage instrumentation. The fuzzing engine uses that instrumentation to find and cache inputs that expand coverage, increasing the likelihood of finding bugs. If the fuzz target fails for a given input, the fuzzing engine writes the inputs that caused the failure to a file in the directory testdata/fuzz/<Name> within the package directory. This file later serves as a seed input. If the file can't be written at that location (for example, because the directory is read-only), the fuzzing engine writes the file to the fuzz cache directory within the build cache instead.

When fuzzing is disabled, the fuzz target is called with the seed inputs registered with F.Add and seed inputs from testdata/fuzz/<Name>. In this mode, the fuzz test acts much like a regular test, with subtests started with F.Fuzz instead of T.Run.

--

## Overview

Fuzzing is a type of automated testing which continuously manipulates inputs to a program to find bugs. Go fuzzing uses coverage guidance to intelligently walk through the code being fuzzed to find and report failures to the user. Since it can reach edge cases which humans often miss, fuzz testing can be particularly valuable for finding security exploits and vulnerabilities.

Below is an example of a [fuzz test](https://go.dev/security/fuzz//#glos-fuzz-test), highlighting its main components.

![Example code showing the overall fuzz test, with a fuzz target within
it. Before the fuzz target is a corpus addition with f.Add, and the parameters
of the fuzz target are highlighted as the fuzzing arguments.](https://go.dev/security/fuzz/example-dark.png) ![Example code showing the overall fuzz test, with a fuzz target within
it. Before the fuzz target is a corpus addition with f.Add, and the parameters
of the fuzz target are highlighted as the fuzzing arguments.](https://go.dev/security/fuzz/example.png)

## Writing fuzz tests

### Requirements

Below are rules that fuzz tests must follow.

-   A fuzz test must be a function named like `FuzzXxx`, which accepts only a `*testing.F`, and has no return value.
-   Fuzz tests must be in \*\_test.go files to run.
-   A [fuzz target](https://go.dev/security/fuzz//#glos-fuzz-target) must be a method call to `[(*testing.F).Fuzz](https://pkg.go.dev/testing#F.Fuzz)` which accepts a `*testing.T` as the first parameter, followed by the fuzzing arguments. There is no return value.
-   There must be exactly one fuzz target per fuzz test.
-   All [seed corpus](https://go.dev/security/fuzz//#glos-seed-corpus) entries must have types which are identical to the [fuzzing arguments](https://go.dev/security/fuzz//#glos-fuzzing-arguments), in the same order. This is true for calls to `[(*testing.F).Add](https://pkg.go.dev/testing#F.Add)` and any corpus files in the testdata/fuzz directory of the fuzz test.
-   The fuzzing arguments can only be the following types:
    -   `string`, `[]byte`
    -   `int`, `int8`, `int16`, `int32`/`rune`, `int64`
    -   `uint`, `uint8`/`byte`, `uint16`, `uint32`, `uint64`
    -   `float32`, `float64`
    -   `bool`

### Suggestions

Below are suggestions that will help you get the most out of fuzzing.

-   Fuzz targets should be fast and deterministic so the fuzzing engine can work efficiently, and new failures and code coverage can be easily reproduced.
-   Since the fuzz target is invoked in parallel across multiple workers and in nondeterministic order, the state of a fuzz target should not persist past the end of each call, and the behavior of a fuzz target should not depend on global state.
